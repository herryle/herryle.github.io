<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://herryle.github.io</id>
    <title>herry&apos;s Blog</title>
    <updated>2023-03-18T07:40:10.275Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://herryle.github.io"/>
    <link rel="self" href="https://herryle.github.io/atom.xml"/>
    <subtitle>万物之中，希望至美</subtitle>
    <logo>https://herryle.github.io/images/avatar.png</logo>
    <icon>https://herryle.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, herry&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[call、apply、bind]]></title>
        <id>https://herryle.github.io/lX7SSHq6U/</id>
        <link href="https://herryle.github.io/lX7SSHq6U/">
        </link>
        <updated>2020-04-14T12:22:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="前言">前言</h2>
<p>在平时面试中，call、apply、bind这三个得用法还是会经常问的，比如三者得区别，作用，或者手写call、apply、bind，因此整理了一下</p>
<h2 id="call-apply-bind作用">call、apply、bind作用</h2>
<p>call() 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及作为一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类似数组对象</a>）提供的参数</p>
<p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<p>这三个解释来自<code>MDN</code>，我们可以发现这三个函数都和this有关系，也就是改变函数运行时this得指向。</p>
<h3 id="举个栗子">举个栗子</h3>
<p>我们先来看一下this指向的代码</p>
<pre><code class="language-js">function Person() {}
Person.prototype = {
  name: 'lee',
  showName: function () {
    console.log(this.name)
  },
}
Person.prototype.showName() 
</code></pre>
<p>上面得代码中调用<code>showName()</code>方法会打印出 <code>lee</code>  ，因为this得指向在这里指向得是 Person这个对象，这个例子很简单吧，再往下看</p>
<pre><code class="language-js">function Person() {}
Person.prototype = {
  name: 'lee',
  showName: function () {
    console.log(this.name)
  },
}

Person.prototype.showName()

let obj = {
  name: 'herry',
}
</code></pre>
<p>我们新增了一个对象字面量，也想打印出name这个变量，怎么办呢？难道我们在直接写一个<code>consloe.log()</code>吗？这多麻烦，那我们可不可以通过Person的<code>showName</code>方法来调用呢？直接复用<code>showName()</code>方法不就好了吗？答案是当然可以。</p>
<pre><code class="language-js">function Person() {}
Person.prototype = {
  name: 'lee',
  showName: function () {
    console.log(this.name)
  },
}

Person.prototype.showName() //lee

let obj = {
  name: 'herry',
}

Person.prototype.showName.call(obj) //herry
Person.prototype.showName.apply(obj) //herry
Person.prototype.showName.bind(obj)() //herry
</code></pre>
<p>上述例子我们就已经看出来call、apply、bind的用法了，他们的作用就是动态改变了上下文，也就是改变了this的指向。</p>
<h2 id="call-apply-bind区别">call、apply、bind区别</h2>
<p>上面的例子中我们分别通过call、apply、bind来实现想要的效果，结果也都是一模一样的，难道就没有一点区别吗？肯定有区别的，要不然设计ES方案的也都是吃饱了没事干的主，那有什么区别呢？从MDN给出的解释中我们也可以找到去别的。</p>
<h3 id="三者区别">三者区别</h3>
<ul>
<li>
<p>call和apply 改变了函数的this上下文之后<strong>便立即执行函数</strong>，bind则是返回改变了上下文后的一个函数。</p>
<p>也就是call 和apply 立即执行，<strong>bind不立即执行</strong></p>
</li>
<li>
<p>call和apply基本类似，但是他们立即传入的参数不一样，call方法接收的时若干个参数列表，apply接收的时一个包含多个的参数的数组</p>
</li>
</ul>
<h3 id="举个栗子-2">举个栗子</h3>
<p>求数组中最大值和最小值</p>
<pre><code class="language-js">var arr = [34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687]
//apply接收数组
Math.max.apply(Math, arr)
//call接收若干个参数
Math.max.call(Math, 34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687)
//bind不会立即执行  要加上()去执行函数
Math.max.bind(Math, 34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687)()
</code></pre>
<p>这个栗子很好的看出来了三者的区别。</p>
<h2 id="手写call-apply-bind">手写call、apply、bind</h2>
<p>我们已经了解了call、apply、bind的作用，也知道了三者的区别，那我们再进一步去手写三者函数，话不多说，搞起来。</p>
<h3 id="手写call">手写call</h3>
<p>我们在来看一下call的定义</p>
<p>call() 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数</p>
<p>也就是说call接收多个参数，最重要的是第一个参数是this，其他的都是函数的参数了。</p>
<p>我们根据这个理解和上面的例子先来写一下</p>
<pre><code class="language-js">Function.prototype.myCall = function (context) {
  //这里得this指向得showName函数
  console.log(this)
  //context指得就是传进来得obj对象，也就是我们指定得this值
  console.log(context)
}
Person.prototype.showName.myCall(obj)
</code></pre>
<p>这里我们先想一下，为什么this的指向指得是<code>showName</code>函数对象呢？</p>
<p>首先我们要明白this的指向，this永远指向最后调用它的那个对象，<code>Person.prototype.showName.myCall(obj)</code></p>
<p><code>myCall</code>最后就是被<code>showName</code>方法来调用的，明白了吗？下面我们继续</p>
<pre><code class="language-js">Function.prototype.myCall = function (context) {
  //这里得this指向得showName函数
  console.log(this)
  //context指得就是传进来得obj对象，也就是我们指定得this值
  console.log(context)
  //传输obj的对象上添加调用的方法
  context.fn = this
  //执行fn
  context.fn()
}

Person.prototype.showName.myCall(obj)  //herry
</code></pre>
<p>awesome！这么简单的吗？ 其实并不是，主要是我们上文这个例子太理想化了，考虑得并不全面，就拿我们上述求数组得最大值和最小值用这个方法都通不过。</p>
<ol>
<li>要考虑call传递参数个数得问题，可能是多个，也可能不传递参数</li>
<li>如果是多参数要把参数传给扩展方法</li>
</ol>
<pre><code class="language-js">Function.prototype.myCall = function (context) {
  //如果没有参数context指向得是window
  context = context || window
  //传输obj的对象上添加调用的方法，这里this得指向是max
  context.fn = this
  //处理参数 去除第一个参数this 其它传入fn函数
  let arg = [...arguments].slice(1)
  //执行fn
  let result = context.fn(...arg)
  //删除fn
  delete context.fn
  //返回执行结果
  return result
}
console.log(Math.max.myCall(Math, 34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687)) //687
</code></pre>
<h3 id="手写apply">手写apply</h3>
<p>上文中我们已经说了 apply和call作用其实是一样的，就是传递参数不一样，apply传递得是参数，所以稍微修改一下即可</p>
<pre><code class="language-js">Function.prototype.myApply = function (context) {
  //如果没有参数context指向得是window
  context = context || window
  //传输obj的对象上添加调用的方法，这里this得指向是max
  context.fn = this
  let result
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}

console.log(Math.max.myApply(Math, [34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687])) //687
</code></pre>
<h3 id="手写bind">手写bind</h3>
<p>bind返回得是函数，不立即执行</p>
<pre><code class="language-js">Function.prototype.myBind = function (context) {
  //返回一个绑定得this，保存this
  let _this = this
  let arg = [...arguments].slice(1)
  //返回一个函数
  return function F() {
    // 处理函数使用new的情况
    if (this instanceof F) {
      return new _this(...arg, ...arguments)
    } else {
      // 返回函数绑定this，传入两次保存的参数
      //考虑返回函数有返回值做了return
      return _this.apply(context, arg.concat(...arguments))
    }
  }
}
console.log(Math.max.myBind(Math, 34, 5, 3, 6, 54, 6, -67, 5, 7, 6, -8, 687)())
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebSocket入门]]></title>
        <id>https://herryle.github.io/ruKEtmUhw/</id>
        <link href="https://herryle.github.io/ruKEtmUhw/">
        </link>
        <updated>2020-04-11T01:57:29.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="前言">前言</h2>
<h2 id="websocket的由来">WebSocket的由来🤞</h2>
<p>我们平时在开发过程中，接触最多的就是HTTP协议了，正常情况下，我们通过客户端向服务端发送HTTP请求，服务器响应请求资源，这个过程我们熟悉的不能再熟悉了。</p>
<p>但是HTTP协议有一个问题就是通信只能由客户端发起，也就是说HTTP协议属于单向通信。</p>
<p>举个栗子，我们在股票中自选某个股票，我们很关心它的价格高于多少时准备卖掉，我们不可能时时刻刻盯着股价来看，这个时候就在想，如果交易所可以自动推送股票的价格该多好，如果采用我们平时HTTP协议做不到服务器主动向客户端推送消息。</p>
<p>当然上述栗子也有办法解决，我们可以使用轮询，即每隔一段时间，客户端就像服务端发起一个询问，但是轮询最大的问题就是效率非常低下，而且很浪费资源，打比方成千上万的韭菜都在关注股票，都在发起请求，那这个请求量就很大了，因此，在很多大佬的努力下，WebSocket就横空出世了！</p>
<h2 id="websocket的优点">WebSocket的优点😊</h2>
<p>从上述举得栗子中就可以很好的看出WebSocket的优点：</p>
<ol>
<li>支持<strong>双向通信</strong>，实时性更好</li>
<li>更好，更轻量与服务端进行通信，因为WebSocket提供了简单的消息规范，<strong>可以更快的适应长连接的环境</strong></li>
<li>支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议，同时可以加密</li>
<li>可以发送文本，也可以发送二进制数据</li>
<li>没有同源策略的限制，客户端可以任意服务器连接（没有同源策略，那我们也可以用来进行解决跨域问题啦🤣）</li>
</ol>
<h2 id="websocket的应用">WebSocket的应用🙈</h2>
<p>现在WebSocket用处很多，最典型的有以下几个</p>
<ol>
<li>聊天室</li>
<li>网站视频弹幕</li>
<li>股票价格实时显示</li>
<li>物联网数据推送</li>
</ol>
<p>还有其他的应用场景，大家可以好好想一想</p>
<h2 id="举个栗子">举个栗子🌰</h2>
<p>说了这么多，我们可以自己来实现一个WebSocket的栗子啦，例子包括了WebSocket服务端、WebSocket客户端（网页端）。完整代码可以在 <a href="https://github.com/herryle/websocket-demo">这里</a> 找到，有帮助的可以帮忙点个⭐️。</p>
<p>上面我们提到WebSocket技术可以应用于股票价格实时显示，那我们就撸一个这样的例子。</p>
<p><strong>先上效果</strong></p>
<figure data-type="image" tabindex="1"><img src="https://herryimg.oss-cn-beijing.aliyuncs.com/1.gif" alt="1" loading="lazy"></figure>
<p>从效果上来看我们可以发现当我们点击开始的时候，客户端就可以请求服务端，服务端去推送实时股价。</p>
<p>好，看完效果我们来撸具体代码</p>
<h3 id="1-客户端">1. 客户端</h3>
<p>客户端先简单说明一下，这里为了方便，采用了Vue和ElementUi，具体代码可以看<a href="https://github.com/herryle/websocket-demo">这里</a> 。</p>
<pre><code class="language-js">    //连接webscoekt
    vm.ws = new WebSocket('ws://localhost:8082')
    //打开websocket
    vm.ws.onopen = function (e) {
      console.log('Connection to server opened')
      //发送消息
      const stockName = vm.ws.send(
        JSON.stringify(
          vm.stockData.map((i) =&gt; {
            return i.name
          })
        )
      )
      console.log('sened a mesg')
    }
    //收到服务器返回消息
    vm.ws.onmessage = function (e) {
      //解析data
      vm.stockData = JSON.parse(e.data)
    }
</code></pre>
<h3 id="2-服务端">2. 服务端</h3>
<p>服务端用了<code>ws</code>这个库。当然大家也可以采用 <code>socket.io</code></p>
<p>首先先安装一下这个库</p>
<pre><code class="language-js">//安装 ws 库
npm  i ws 
</code></pre>
<p>下面开始写server.js</p>
<pre><code class="language-js">const WebSocket = require('ws')

//生成WebSocket服务端
const wss = new WebSocket.Server({ port: 8082 })

function randomInterval(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min) / 100
}

//websocket连接
wss.on('connection', function (ws) {
  //接收信息
  ws.on('message', function (message) {
    stockRequest = JSON.parse(message)
    console.log('收到消息', stockRequest)
  })

  //模拟股票价格
  const clientStockUpdater = setInterval(function () {
    for (let i in stockRequest) {
      stockRequest[i].price += randomInterval(-100, 100)
      //推送消息
      ws.send(JSON.stringify(stockRequest))
    }
  }, 1000)

  //关闭websocket
  ws.on('close', function () {
    clearInterval(clientStockUpdater)
  })
})

</code></pre>
<h2 id="结语️">结语✍️</h2>
<p>看完以上是不是发现WebSocket很简单，其实本文只是一个WebSocket入门教程，大家不妨自己动手写一下，在我这个例子上在加深一下，探究一下WebSocket的加密以及心跳机制等。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Sam Altman: How To Be Successful ]]></title>
        <id>https://herryle.github.io/106/</id>
        <link href="https://herryle.github.io/106/">
        </link>
        <updated>2020-02-28T02:10:58.000Z</updated>
        <content type="html"><![CDATA[<p>作者 Sam Altman：美国人，创业者、投资人、程序员以及博主。目前是最知名创业孵化器 Y Combinator 的CEO，OpenAI的联合主席。</p>
<p><a href="https://blog.samaltman.com/how-to-be-successful">原文链接</a></p>
<p>（正文）</p>
<p>我观察过数以千计的创始人，一直思考到底是什么使得她/他们能够创造这些巨大财富或者重要创新呢。一般都是先从追求财富开始，最终变成了追求创新。</p>
<p>基于这些观察，在如何能取得巨大的成功这个问题，我获得了十三个洞察。假如你已经具备一定的经济条件，无论是因为家庭条件好还是通过自身积累，现在想追求进一步的成功的话，（相对完全没有积累的人）这些方法对你来说会容易很多。不过基本上还是适合所有人啦。</p>
<p>（译者注：关于为什么已经具备一定（经济）条件对追求成功很重要，Sam Altman在文末附上了他对这个问题回答。个人觉得这个回答放到正文开始前，会更有启发，所以我就把它翻译到前面了。下面就是 Sam 对这个常见问题的回答。概括起来就是一个事实提醒：并不是每个人只要努力就能成功，出身和运气也很重要。）</p>
<p>为什么我认为有一份基本收入如此重要呢，因为它能释放人更大的潜力，让人们愿意去冒险。</p>
<p>而在这之前，如果你不是生在有钱有势家庭，你就得自己先辛苦打拼积累一段时间，然后才有可能够得着一些东西。如果你出生赤贫，这里所说的一切对你来说都会极其艰难😔</p>
<p>机会是如此的不均等，这是一个让人无比遗憾的事实。但是我也亲眼见证过足够生来就受到各种挑战的人，也获得了让人自豪的成就。这让我相信这样的人成功也是可能的。</p>
<p>但同时，我也非常清醒地知了这样的事实：如果我不是生得幸运，我不会是现在的我。</p>
<p>（译者注：下面回到正文）</p>
<p><strong>1. Compound yourself 寻找复合增长曲线</strong></p>
<p>复合增长具有魔力。每个人都在四处寻找这样的机会。指数复合增长是财富增长的关键。</p>
<p>一个中等规模企业，如果保持年复合50%的增长，用不了多少年就会变成巨无霸。传统上很少有企业能有这样有网络效应和极端扩张能力。但加上科技的手段就不一样了，会有越来越多这样的机会。所以值得你花大力气去寻找或者创造这样能复合增长的机会。</p>
<p>（译者注：假如年复合增长50%，5年后总量将增长7倍，10年则增长58倍）</p>
<p>你个人肯定也想获得指数成长的能力，所以你应该将目标放在能跳上一条增长陡峭的轨道。这样的话，选择有复合增长效应的工作就很重要了，因为大多数的工作最多能做到线性增长。</p>
<p>如果做两年和做二十年的人水平都差不多，这样的工作你肯定不想做吧。你应该保持快速的的学习能力。在工作中所做每部分的贡献，都应该要能产出越来越多的成果。其实有很多方式能获得这种杠杆效应，比如资本、技术、品牌、网络或者发起更多的人协作。</p>
<p><strong>不管你的成功是金钱、地位、影响力或者其他的，你都应该专注如何在后面再加一个零。</strong>（译者注：即增加一个数量级）</p>
<p>为了找到我的下一个大项目，我总是愿意花足够多的时间来看各种各样的项目。但在我心目中，真正的大项目是那种如果成功了就能作为我后半辈子职业生涯注脚的。</p>
<p>大多数人深陷线性增长机会的思路中，因此仍会愿意给专注潜在阶跃变化的项目一些机会。</p>
<p>（译者者：阶跃函数是一种特殊的连续时间函数，是一个从0跳变到1的过程，属于奇异函数。Sam Altman 认为这种阶跃潜力跟指数增长比起来并不值得投资。）</p>
<p>不管是对公司还是对职场人，我认为商业上最大的竞争优势在于，在更宽广的维度，对世界上运作着的各种差异巨大的系统之间协调运作机制的长期思考。<strong>复合增长的一个显著特点就是：最远的未来是最为重要的。现实世界中几乎没有多少人会真正带着长远的眼光看问题，所以市场会对拥有这种眼光的人予以丰厚的回报。</strong></p>
<p>相信指数增长，保持耐心，最后欣然接受丰厚的回报吧。</p>
<p><strong>2. Have almost too much self-belief “过分地”相信自己</strong></p>
<p>「相信自己」是一种无比强大的力量。我所知的最成功的人都是相信自己到有点自大的地步。</p>
<p>要尽早培养这种观念。一旦你的判断是对的而且因此能持续地达成结果，这样的数据/经历越多，你就越进一步地相信自己。</p>
<p>如果你不相信自己，就很难对未来拥有不同常人的独特见解，而这是大部分价值创造的关键。</p>
<p>我还记得很多年前，伊隆·马斯克带我参观 SpaceX 工厂时的情景。他跟我讲了很多建造火箭每个部分的细节，但最让我记忆犹新的是，当他说起要把大型火箭送到火星时，脸上那种无比坚定的表情。当时回去就在想：嗯，这就是有坚定信念的人该有的样子。</p>
<p>保持自己斗志，同时让团队也保持士气，是所有努力中最有挑战的事情之一了。如果你不足够相信自己，让自己和团队保持士气几乎是不可能的。而且不幸的是，一般你的野心越大，你受到的打击也会越大。</p>
<p>大部分最成功的人都有至少一次这样的经历：某次对未来的判断是正确的，虽然其他所有人都觉得她/他们错了。因为要不是这样，她/他们就会面临无数竞争者。</p>
<p>另外，自我信念和自我认知要把握好平衡。过去我是一点点批评都受不了，总是想方设法地避开。不过现在我的做法不一样了，我会先倾听并假设这个批评是对的，然后再思考要不要采取进一步行动。追求真理并不是容易，而且常常是非常痛苦的，但这也是区分信念和妄念试金石。</p>
<p>（译者注：自我认知是心理学术语，指的是“主观的我” 对&quot;客观的我” 的认识和评价。自我认知让我们直觉地认为，别人批评是一种威胁或攻击。在这里作者说了他是如何克服的。）</p>
<p>如果对二者有更清楚的认知，会避免让你看起来好像合格，并确保你是在正确的路上。</p>
<p>（译者注：这里说的是我们要有清楚的自我认知，才能知道自己适不适合做，是否有能力做，而不是空有一腔热血。）</p>
<p><strong>3. Learn to think independently 学会独立思考</strong></p>
<p>创业其实很难教，因为如何获得原创想法很难教。我们的学校不仅不教这个，反而是鼓励其反面。所以你需要自己培养起来。</p>
<p>（译者注：学校更喜欢听话守规矩、能既定规则中考高分的学生，所以是反面。）</p>
<p>从第一性原理出发，尝试提出不同的新想法，这很有趣。然后找到一群人，跟他们交换自己的新想法，是一个让你做得更好的好方法。再下一步就是找到一种简易又迅速的方式，在现实世界中验证这些想法。</p>
<p>“我会失败很多次，但至少会有一次我的想法是对的。” 这是创业者应有的态度。所以你需要让自己获得幸运之神眷顾的几率尽可能地变大。（译者注：即尽可能多的尝试）</p>
<p>在这个过程中，你能学到的最重要的东西之一是：如何在看似没有解决办法的情况下找到解决方案。一旦这样的事情做得越多，就会越相信自己一定能解决这个问题。坚毅总是在一次次被打倒后又重新站起来中学到的。</p>
<p><strong>4. Get good at “sales” 学会 “推销”</strong></p>
<p>光是有信念是不够的，你还需要有能力说服他人相信你所相信的。</p>
<p>所有伟大的工作，从某种程度上，最终都是在推销。你要向你的客户、可能的雇员、媒体、投资人等等所有人布道。这需要你有一个鼓舞人心的愿景、超强的沟通能力、一定的领导魅力以及过硬的执行力。</p>
<p>提升沟通能力，特别是写作沟通能力，是很值得做的事。在如何进行有效沟通上，我最好的建议是：先要确保自己想清楚了，然后用简洁明了的语言表达出来。</p>
<p>做好推销最好办法是发自内心相信你所推销/布道的东西。推销自己真正相信的，这种感觉很美妙。如果是卖狗皮膏药之类，那就感觉很糟糕了。</p>
<p>就像其他任何技能一样，推销技能也是可以练习的。只有经过刻意练习任何人都会得到提升。但是由于一些原因，可能是因为推销让人反感，很多人认为这项技能是学不会的。</p>
<p>关于如何更好地推销，我还有一个建议就是：任何重要的时刻都要进行面对面的沟通。当我刚刚起步时，我总是愿意坐飞机飞来飞去。有时常常是没有必要的，但是其中有三次，为我带来了改变职业方向的大机会，要不然情况可能就完全不一样了。</p>
<p><strong>5. Make it easy to take risks 轻装上阵 | 让冒险更容易</strong></p>
<p>大多数人会高估风险，低估回报。承担一定风险很重要，因为你不可能总是对的，你得不断尝试不同的东西，在了解更多情况后快速适应和调整。</p>
<p>在职业发展早期通常更容易去冒险，毕竟也没什么可失去的，却极有可能收获更多。而到肩上有了一定责任的阶段，你就应该有意识地让冒险变得仍然可行。看看周围有没有这样确定的机会：如果输了损失一倍，如果赢了获得100倍回报。然后在这个方向上加大赌注。</p>
<p>准备时间也不要太长。在YC，我们注意到创始人们常常有个问题就是，花了太长时间在 Google 或者 Facebook 这样的大公司工作。人一旦习惯了舒适的生活、完全可预期的工作以及不管因什么原因带来的成功名声时，就会变得很难舍弃这些东西 (人总是出奇地有一种能按照明年的收入来划算现在生活标准的优秀能力)。就算他们真的逃脱了舒适区，想跳回去的诱惑也非常大。因为这样更容易，跟延迟满足比起来，人总是优先考虑短期利益和便利，人性使然。</p>
<p>但是一旦跳下“跑步机”，你就能跟从自己的直觉，把时间花在那些可能最终被证明是非常有价值的事情上。这里有个能帮你从“跑步机”跳下来的方法，那就是尽可能让生活保持便宜和灵活。当然肯定会有舍有得。</p>
<p><strong>6. Focus 专注</strong></p>
<p>专注让你的工作事半功倍。</p>
<p>几乎我认识的所有人都认为，应该在专注什么的问题上花更多时间的思考。做对的事情比卖力工作重要太多。多数人把大部分的时间浪费在了无关紧要的事情上。</p>
<p>一旦你想明白了要做的事，就赶紧以“谁也无法阻拦我”的热情把待做事项一项项完成吧。我还没有碰到过行动力迟缓却能成功的人。</p>
<p><strong>7. Work hard 保持勤奋</strong></p>
<p>通过聪明才智或者勤奋，你都有可能成为所在领域的前10%，当然这已经是不错的成就了。但想成为前1%，就需要你既聪明又勤奋了。因为跟你竞争的是那些天资聪慧，有绝妙想法又愿意努力工作的人。</p>
<p>极端的人能获得极端的成就。拼命工作会在生活方面牺牲很多，因此不认同这种观念也是理性选择。但勤勉工作的好处也是很大的。在多数情况下，动量会叠加，成功会带来更多的成功。</p>
<p>其实努力工作也可以是很有趣的。人生的一大乐趣就是找到自己使命，再把它变成自己擅长的事，然后会发现你能对比自己更大的世界产生影响。有一位YC的创始人最近跟我表示，他从没想到过从大公司离职并专注最大化自己的影响力后，会有这么大的快乐与满足。在这样事情上努力工作应该被鼓励。</p>
<p>我不是完全明白，为什么在美国一些地区努力工作变成了一件<strong>坏事</strong>。但可以肯定的是在世界上很多其他地方并不是这样，在美国之外的创业者们展现出的激情和内驱力正在迅速成为新的模范。</p>
<p>当然你也需要知道该如何在勤勉工作的同时又不被累垮。对这个问题每个人都有自己的策略。不过有个方法是通用的，那就是跟自己喜欢在一起工作的人，做自己想做的事。</p>
<p>我认为那些假装让你觉得即使不把大部分时间（在一定人生阶段）花在工作上也能在职业上获得巨大成功的人，是在误导你。事实上，是否勤奋工作似乎是预测是否会取得长期成功最主要的因素之一了。</p>
<p>关于勤勉工作还有一点就是：在职业生涯的早期进行。努力工作形成的复合效应就是像收利息。开始得越早，就越早产生收益。当然也是因为，越早你的责任和负担越少，这是一般情况也可能有例外。</p>
<p><strong>8. Be bold 大胆一点</strong></p>
<p>我始终相信一点：<strong>进行难度大的创业比做普通的创业项目要容易</strong>。因为大家都想参与真正让人兴奋的事业，这样才会感觉到自己工作的意义。</p>
<p>如果你在一个重要问题上取得了一定进展，将会有一群想搭顺风车的人想要帮你。让自己更有野心一点，不要回避自己真正想要做的事。</p>
<p>如果其他人都在做 meme 公司，而你想要创建一家基因编辑公司，开始做吧，不要迟疑。</p>
<p>（译者注：meme 音 [miːm]，是在《自私的基因》中提出的类同gene基因的概念。指的是文化上的复制基因，通过模仿来传递。比如苹果产品背后的理念其实比实际产品更强大，这种理念就是一种meme。作者在这里把”meme公司”和“基因编辑公司”对应，是想说即使你想做的做跟其他人都不一样，也没关系，相信自己的直觉勇敢去做。）</p>
<p>追随自己的好奇心。那些让你兴奋的东西通常也会让别人感到兴奋。</p>
<p><strong>9. Be willful 意志坚定</strong></p>
<p>有个很多人不知道的秘密就是，人其实有很大的概率能让世界屈从于自己的意志。多数人从来不曾尝试，只是老老实实地接受现状。</p>
<p>人有着巨大的能力去做成一件事。往往是自我怀疑、过早放弃或者没有尽到全力让多数人远没有挖掘出自身潜力。</p>
<p>**大胆追求自己想要的东西。**通常你会得不到，而且会在被拒绝时感到痛苦万分。可一旦这种方式起到作用了，就会出奇得有效。</p>
<p>那些说 “我一定要坚持到最后，不管遇到什么样的挑战，我都有办法解决” 而且说到做到的人，最后都成功了。因为她/他们坚持的时间足够长，长到了运气的降临。</p>
<p>Airbnb 是这方面的一个标杆。他们告诉我太多这样肯定没人想要再次经历的故事（刷爆了放在那种孩子用来收集棒球卡的9格活页夹里的所有信用卡，每顿都会吃一元店里麦片粥，一次次地跟强大的既得利益作斗争诸如此类）但是他们最终还是存活到了好运来临的时候。</p>
<p>要想意志坚定，就得保持乐观。乐观的个性是有望可以通过练习来培养的。我还真没有碰到过一位个性悲观的成功人士呢。</p>
<p><strong>10. Be hard to compete with 拥有独特竞争力</strong></p>
<p>多数人都能理解，作为一个公司，竞争力越强就越有价值。这很重要，显而易见也是对的。</p>
<p>但其实对个人而言也是这样的。<strong>如果你能做的事别人也能做，你最终会被更低成本的人所代替。</strong></p>
<p>增强自己竞争力的最好方式就是建立杠杆。比如，你可以借助人际关系、建立强大的个人品牌或者进行跨领域交叉。还有很多这样的策略，你得找到具体的事做起来。</p>
<p>大多数人都是看周围的人做什么就做什么。这样的跟风行为通常方向是错的。如果你做的跟别人没什么区别，就不可能拥有独特竞争力。</p>
<p><strong>11. Build a network 积累人脉</strong></p>
<p>成就伟大的事业需要团队。跟或近或远工作关系中的人才建立很好的联系，对职业成功至关重要。能同多少你知道的真正聪明的人建立人脉关系，决定了能成就多大的事业。</p>
<p>积累人脉最有效方式是尽可能地帮助他们。长期以来我都在这么做，这在职业上为我带来了多数的好机会，以及我最好投资项目中的三个都是这么来的。至今这样的好事还时常发生，可能因为十年前我帮助过某位创始人。</p>
<p>最好的积累人脉的方式之一是，为自己建立起 “非常照顾跟自己一起工作的人” 的名声。慷慨地分享这个优势，这会为你带来10倍回报。而且要学会正确评估他人的优势，将人才放到合适的位置上。（这是我在管理方面学到的最重要的东西，虽然在这方面我研究得还不多）你应该有这样的名声：<strong>能“逼迫” 他人达成他们自己认为做不到的成就，但又不会逼过头。</strong></p>
<p>每个人都会在一些事情上做得比别人好。<strong>要用自己长处而不是短处来定义自己</strong>。承认自己的不足，然后想出一个变通方案，而不是因此放弃要做的事。“因为我不擅长X，所以我做不了Y” 我太常听到创业者说这样的话了，主要还是说明缺乏创造力。补足自己短板的最好方式是找互补的团队成员，而不是只招跟自己擅长同样东西的人。</p>
<p>在积累人脉的过程中，特别有价值的一个地方就是，自己会变得善于发现那些尚未被挖掘到的人才。迅速发现能人、开车、创造性等都会因练习得多而更容易。学习的最简单方式就是见很多人，跟踪记录让你印象深刻的人和当时没有突出印象的人。这里要记住一点，你主要是在寻找成长性，所以不要太看重过往的经验和目前的成就。</p>
<p>每次认识新的人时，我总会问自己 “这是她/他的天性吗？” 在寻找那些可能成就卓越的人方面，这是一个非常好的启发式问题。</p>
<p>还有一个积累人脉的特例就是，找那些愿意跟你一起赌未来的牛人，最好是在事业刚起步的时候。找到他们的最好方式毫无疑问是想办法让自己变得 “有用”。（要记住在之后某个时间点应该给予其相应回报）</p>
<p>最后的最后，记住<strong>把时间花在那些支持你野心的乐观的人身上</strong>。</p>
<p><strong>12. You get rich by owning things 拥有才是真正的财富</strong></p>
<p>我小时候在经济学方面最大误解就是：人是通过获得高工资而变得富有的。事实上，福布斯历史上几乎没有人因为工资高而上榜，虽然也有个别例外，比如演艺圈人士，</p>
<p>拥有持续增值的东西才能真正地富有起来。</p>
<p>这些东西可能是拥有一个公司、房产、自然资源、知识产权或者其他类似的东西。但不管以什么方式，你需要拥有一些东西的股权，而不单是出卖自己的时间。出卖时间只能是线性增长。</p>
<p>创造有持续增长价值的东西的最好方法是，做出人们需要的可规模化的产品。</p>
<p><strong>13. Be internally driven 要有内在驱动</strong></p>
<p>多数人主要是由外在驱动的。他们做什么事主要是为了做给别人看的。因为各种原因这种情况有很多坏处，下面是其中最重要的两点。</p>
<p>首先，你会在一般的工作轨道上做着一般的工作。因为你特别在意别人是否认为自己在做正确的事，这种在意程度超乎你想象。这样一来就会阻碍你做真正有意思的事。即使你这样做了，也会发现有人在做了。</p>
<p>第二，你通常会进行错误的风险计算。你会非常关注是否跟上了别人的脚步，是不是在竞争游戏中落后了，哪怕是短期竞争。</p>
<p>聪明的人似乎特别容易有这样外在驱动的行为。能保持觉察当然有帮助，但还远远不够。这可能需要付出极大的努力才能避免落入 “模仿者” 陷阱。</p>
<p>我所知的大多数有成就的人都主要是内在驱动。她/他们是为了成为更好的自己，不断创造是因为觉得世界上没有这样的东西就不行。在你赚了足够多的钱，可以买任何想买的东西，也获得足够高的社会地位后，就没什么乐趣再继续努力了，而内在的驱动力是我所知的，能继续驱动你取得更高成就的唯一动力。</p>
<p>这是为什么问一个人努力的动机是什么如此重要。这是我想要了解一个人最先想知道的。什么是对的动机很难用一些标准来衡量，不过一旦看到就能明白了。</p>
<p>我认为 Jessica Livingston 和 Paul Graham 是这方面的典范。YC 在最初的几年都是在被人被嘲笑，在起步阶段几乎没有人相信这样能获得成功。但创始人们觉得如果要是成了，肯定会让这个世界更好。她/他们总是乐于帮助别人，并且深信这种新模式比现有的模式更好。</p>
<p>最后，你会把在自己认为很重要的领域取得优异表现作为成功的标准。沿着这个方向，起步得越早，你就能走得越远。如果不是做自己真正着迷的事，是很难取得巨大成就的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[What's Vue？ Why Vue？]]></title>
        <id>https://herryle.github.io/103/</id>
        <link href="https://herryle.github.io/103/">
        </link>
        <updated>2020-02-27T06:47:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="vuejs新手入门指南">Vue.js新手入门指南😃</h3>
<p>最近在逛各大网站，论坛，以及像SegmentFault等编程问答社区，发现Vue.js异常火爆，重复性的提问和内容也很多，楼主自己也趁着这个大前端的热潮，着手学习了一段时间的Vue.js，目前用它正在做自己的结业项目。<br>
在做的过程中也对Vue.js的官方文档以及其各种特性有了许多认识。作为一个之前以PHP+模版引擎为主的开发，从一个从未接触过除HTML+CSS+JavaScript+JQuery以外的前端技术的人到现在可以独立使用Vue.js以及各种附属的UI库来开发项目，我总结了一些知识和经验想与大家分享。</p>
<p>下面我就以问答的形式来分享吧。这里假设你仅仅只掌握了HTML+CSS+JavaScript，如果你对JQuery这个前端库，以及各种后端模版语言比如说PHP，JSP还有所了解并且使用过的话那就太好了。</p>
<h4 id="1vuejs是什么">1.Vue.js是什么？</h4>
<p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。</p>
<p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<p>如果你是有经验的前端开发者，想知道 Vue.js 与其它库/框架的区别，查看对比其它框架。</p>
<p>这是官网的介绍，是不是觉得非常的抽象非常的官方？看完之后可能还是有很多人不是很懂这个框架到底是用来做什么的，什么是“渐进式框架”？什么是“自底向上增量开发”？什么是“视图层”？什么是“单文件组件”？什么是“复杂的单页应用？”第二段话里面“响应的数据绑定和组合的视图组件”这又是个啥？还有最后一段话，“Vue.js 与其它库/框架的区别”究竟是什么？</p>
<p>不要担心，如果你慢慢看完这里面的所有问答，一定会对前面那些可能你从未听说过的专业术语有一种恍然大悟的感觉。</p>
<h4 id="2vuejs到底是什么">2.Vue.js到底是什么？</h4>
<p>想必现在能看到我这篇文章的人，都是用着APP或者网页版知乎在阅读把。Vue.js就是一个用于搭建类似于网页版知乎这种表单项繁多，且内容需要根据用户的操作进行修改的网页版应用。</p>
<h4 id="3单页应用程序spa">3.单页应用程序（SPA）</h4>
<p>顾名思义，单页应用一般指的就是一个页面就是应用，当然也可以是一个子应用，比如说知乎的一个页面就可以视为一个子应用。单页应用程序中一般交互处理非常多，而且页面中的内容需要根据用户的操作动态变化。</p>
<h4 id="4你前面说的网页版知乎我也可以用jquery写啊为什么要用vuejs呢">4.你前面说的网页版知乎我也可以用JQuery写啊，为什么要用Vue.js呢？</h4>
<p>讲到JQuery，就不得不说到JavaScript的DOM操作了。如果你用JQuery来开发一个知乎，那么你就需要用JQuery中的各种DOM操作方法去操作HTML的DOM结构了。</p>
<p>现在我们把一个网页应用抽象一下，那么HTML中的DOM其实就是视图，一个网页就是通过DOM的组合与嵌套，形成了最基本的视图结构，再通过CSS的修饰，在基本的视图结构上“化妆”让他们看起来更加美观。最后涉及到交互部分，就需要用到JavaScript来接受用户的交互请求，并且通过事件机制来响应用户的交互操作，并且在事件的处理函数中进行各种数据的修改，比如说修改某个DOM中的innerHTML或者innerText部分。</p>
<p>我们把HTML中的DOM就可以与其他的部分独立开来划分出一个层次，这个层次就叫做视图层。</p>
<p>Vue 的核心库只关注视图层<br>
我们为什么要把视图层抽取出来并且单独去关注它呢？</p>
<p>因为在像知乎这种页面元素非常多，结构很庞大的网页中，数据和视图如果全部混杂在一起，像传统开发一样全部混合在HTML中，那么要对它们进行处理会十分的费劲，并且如果其中有几个结构之间存在藕断丝连的关系，那么会导致代码上出现更大的问题，这什么问题呢？</p>
<p>你是否还记得你当初写JQuery的时候，有写过<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;#&#039; at position 3: (&#039;#̲xxx&#039;).parent().…'>(&#039;#xxx&#039;).parent().parent().parent()这种代码呢？当你第一次写的时候，你觉得页面元素不多，不就是找这个元素的爸爸的爸爸的爸爸吗，我大不了在注释里面写清楚这个元素的爸爸的爸爸的爸爸不就好了。但是万一过几天之后你的项目组长或者你的产品经理突然对你做的网页提出修改要求，这个修改要求将会影响页面的结构，也就是DOM的关联与嵌套层次要发生改变，那么</span>('#xxx').parent().parent().parent()可能就会变成$('#xxx').parent().parent().parent().parent().parent()了。</p>
<p>这还不算什么，等以后产品迭代越来越快，修改越来越多，而且页面中类似的关联和嵌套DOM元素不止一个，那么修改起来将非常费劲。而且JQuery选择器查找页面元素以及DOM操作本身也是有性能损失的，可能到时候打开这个页面，会变得越来越卡，而你却无从下手。</p>
<p>当你在编写项目的时候遇到了这种问题，你一定会抱怨，为什么世上会有HTML这种像盗梦空间一样的需要无数div嵌套才能做出页面的语言，为什么当初学JQuery看中的是它简洁的DOM操作，现在却一点也不觉得它有多简洁，难道我学的是假的JQuery？为什么写个代码这么难，你想砸电脑，你想一键盘拍在产品狗的脑袋上，责怪他天天改需求才让你原本花清香茶清味的代码变得如此又臭又长。</p>
<p>这个时候如果你学过Vue.js，那么这些抱怨将不复存在。</p>
<h4 id="5vuejs为什么能让基于网页的前端应用程序开发起来这么方便">5.Vue.js为什么能让基于网页的前端应用程序开发起来这么方便？</h4>
<p>因为Vue.js有声明式，响应式的数据绑定，与组件化的开发，并且还使用了Virtual DOM这个看名字就觉得高大上的技术。</p>
<p>可是这些名词都是啥？</p>
<h4 id="6响应式的数据绑定">6.响应式的数据绑定</h4>
<p>这里的响应式不是@media 媒体查询中的响应式布局，而是指vue.js会自动对页面中某些数据的变化做出响应。至于是如何响应的，大家可以先把下面这段代码随便粘贴到一个扩展名为html的文件然后用浏览器打开，随便在文本框里面输入一些文字，观察一下页面变化。</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
	&lt;meta charset=&quot;UTF-8&quot;&gt;
	&lt;title&gt;vue.js测试 - 代码之美专栏&lt;/title&gt;
	&lt;!-- author:昌维 代码之美 https://zhuanlan.zhihu.com/codes --&gt;
	&lt;script src=&quot;https://unpkg.com/vue/dist/vue.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
	&lt;div id=&quot;app&quot;&gt;
		&lt;input type=&quot;text&quot; name=&quot;&quot; value=&quot;&quot; placeholder=&quot;在这里输入文字，下面会跟着变化&quot; v-model=&quot;message&quot;&gt;
		&lt;hr&gt;
		&lt;p&gt;{{ message }}&lt;/p&gt;
	&lt;/div&gt;
	&lt;script type=&quot;text/javascript&quot;&gt;
		var app = new Vue({
		  el: '#app',
		  data: {
		    message: 'Hello Vue!'
		  }
		})
	&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>是不是会发现一个很神奇的现象，文本框里面输入的文字和后面的p标签中的内容一起变化？</p>
<p>换句话说，p标签里面通过{{ message }}这个写法与input标签中的value绑定在了一起，其中变化，另外一个和它绑定的数据就跟着变化。</p>
<p>结合标题来说，就是vue.js会自动响应数据的变化情况，并且根据用户在代码中预先写好的绑定关系，对所有绑定在一起的数据和视图内容都进行修改。而这种绑定关系，在图上是以input 标签的v-model属性来声明的，因此你在别的地方可能也会看到有人粗略的称vue.js为声明式渲染的模版引擎。</p>
<h4 id="7组件化开发">7.组件化开发</h4>
<p>还记得在传统前端开发的时候，我们都是每个人做一个页面，然后最后套入各种后端模版引擎，比如说PHP的Smarty或者Java的JSP等等。</p>
<p>但是现在我们做单页应用，页面交互和结构十分复杂，一个页面上就有许许多多的模块需要编写，而且往往一个模块的代码量和工作量就非常庞大，如果还按照原先的方法来开发，那么会累死人。而且遇到以后的产品需求变更，修改起来也非常麻烦，生怕动了其中一个div之后，其他div跟着雪崩，整个页面全部乱套，或者由于JavaScript的事件冒泡机制，导致修改一些内层的DOM事件处理函数之后，出现各种莫名其妙的诡异BUG。</p>
<p>在面向对象编程中，我们可以使用面向对象的思想将各种模块打包成类或者把一个大的业务模块拆分成更多更小的几个类。在面向过程编程中，我们也可以把一些大功能拆分成许多函数，然后分配给不同的人来开发。</p>
<p>在前端应用，我们是否也可以像编程一样把模块封装呢？这就引入了组件化开发的思想。</p>
<p>Vue.js通过组件，把一个单页应用中的各种模块拆分到一个一个单独的组件（component）中，我们只要先在父级应用中写好各种组件标签（占坑），并且在组件标签中写好要传入组件的参数（就像给函数传入参数一样，这个参数叫做组件的属性），然后再分别写好各种组件的实现（填坑），然后整个应用就算做完了。</p>
<h4 id="8virtual-dom">8.Virtual DOM</h4>
<p>现在的网速越来越快了，很多人家里都是几十甚至上百M的光纤，手机也是4G起步了，按道理一个网页才几百K，而且浏览器本身还会缓存很多资源文件，那么几十M的光纤为什么打开一个之前已经打开过，已经有缓存的页面还是感觉很慢呢？这就是因为浏览器本身处理DOM也是有性能瓶颈的，尤其是在传统开发中，用JQuery或者原生的JavaScript DOM操作函数对DOM进行频繁操作的时候，浏览器要不停的渲染新的DOM树，导致页面看起来非常卡顿。</p>
<p>而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。</p>
<p>对于vue.js的Virtual DOM，目前业界有着褒贬不一的评价。有人认为Vue.js作为一个轻量级框架，引入Virtual DOM会加大Vue.js本身的代码尺寸，也会消耗更多CPU（手机上会更耗电）（注意：消耗更多的CPU并不意味着会更卡，因为JavaScript计算是后台计算，他的计算量还不至于让DOM操作变得卡顿），并且在操作单个DOM元素的时候，反而多了一道计算工序，会更慢。但也有人认为基本上会用Vue.js开发的都是页面中内容很多的元素，肯定操作的DOM量级普遍较大，平均一下还是比较划算的。</p>
<h4 id="9我到底该怎么用vuejs做单页应用开发">9.我到底该怎么用Vue.js做单页应用开发？</h4>
<p>说了这么多，我还是不知道怎么用它做出一个像知乎那样的页面啊，到底怎么学它呢？</p>
<p>前面我们看了一个响应式的数据绑定案例，那只是一个DEMO，而且也看不出有什么实际意义，离真正的单页应用程序还差得远，到底怎么用它开发真实的项目呢？</p>
<p>我的建议是，先把介绍 - vue.js官方文档的基础部分硬着头皮看一遍。除了组件这个小节涉及到了很多晦涩难懂的名词以外，前面几章完全就是把Vue.js当作一个模版引擎来用。</p>
<p>然后开始学习ECMAScript6，Webpack，NPM以及Vue-Cli的基本用法，最好对Node.js也要有所了解。</p>
<p>最后组件部分先大致看一遍，了解组件里面都有哪些概念之后，开始看网上各种实战视频以及文章还有别人开源的源代码。</p>
<h4 id="10在前面你提到过好几次ecmascript这是啥">10.在前面你提到过好几次ECMAScript，这是啥？</h4>
<p>ECMAScript听名字好像和JavaScript很像，难不成他们有什么千丝万缕的联系？</p>
<p>没错你猜对了，他们之间还真有着很深的联系。</p>
<p>引用阮一峰老师的话：（ECMAScript 6入门）</p>
<p>要讲清楚这个问题，需要回顾历史。1996年11月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是1.0版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<p>而ECMAScript6就是新一代的JavaScript语言。</p>
<p>这里也强烈推荐大家学习ECMAScript6的时候参考这本书ECMAScript 6入门</p>
<h4 id="11我在学习vuejs的时候老是听到webpack这是啥">11.我在学习Vue.js的时候老是听到Webpack，这是啥？</h4>
<p>Webpack是一个前端打包和构建工具。如果你之前一直是手写HTML，CSS，JavaScript，并且通过link标签将CSS引入你的HTML文件，以及通过Script标签的src属性引入外部的JS脚本，那么你肯定会对这个工具感到陌生。不要紧，我们先来了解一下为什么要用Webpack，然后带着原因去学习就好了。</p>
<h4 id="12为什么要用webpack">12.为什么要用Webpack</h4>
<p>前面说了，做一个单页应用程序本身就相当复杂，而且在做的时候肯定会使用到很多素材和别的第三方库，我们该如何去管理这些东西呢？</p>
<p>还有前面讲到了Webpack是一个前端打包工具，前端代码为什么要打包呢？因为单页应用程序中用到很多素材，如果每一个素材都通过在HTML中以src属性或者link来引入，那么请求一个页面的时候，可能浏览器就要发起十多次请求，往往请求的这些资源都是一些脚本代码或者很小的图片，这些资源本身才几k，下载连1秒都不需要，但是由于HTTP是应用层协议，它的下层是TCP这个运输层协议，TCP的握手和挥手过程消耗的时间可能比下载资源本身还要长，所以需要把这些小文件全部打包成一个文件，这样只要一次TCP握手和挥手的过程，就把多个资源给下载下来了，并且多个资源由于都是共享一个HTTP请求，所以head等部分也是共享的，相当于形成了规模效应，让网页展现更快，用户体验更好。</p>
<p>前面说到Webpack还有构建的功能，这就不得不提到了ECMAScript6这个新版本的JavaScript，但是现在国内外还有很多人用着老版本的浏览器，这些浏览器并不支持ECMAScript6，那么我们的前端项目如何在这种浏览器上运行呢？这就需要Webpack的Loader自动载入一个转换器来将我们写的ECMAScript6转换成浏览器能支持的老版本JavaScript语言，这个转换器的名字叫做babel，如果你以后听到或者看到了这个单词，应该要知道它就是一个ECMAScript6 to 老版本JavaScript的转换器了。这也是Webpack的构建功能。当然对前端有更深入的同学还会知道Sass，Less，stylus之类的CSS预处理器，我们也可以通过在Loader中编写特定的规则来实现自动将这些CSS预处理语言转换成普通浏览器能识别的CSS代码。</p>
<p>开头的介绍提到了vue.js可以使用单文件组件开发项目，其实也是通过Webpack将单文件组件中的模版，样式以及JS转换到主页面中</p>
<p>当然Webpack不止这点功能，它还可以通过安装各种插件来扩展，比如说热加载技术，就是解放键盘的F5键。让我们修改代码，并且按Ctrl+S保存之后，浏览器页面自动刷新变化，不需要我们去手动刷新，还有一些插件可以自动添加注释，自动给CSS代码加上一些浏览器内核对CSS3兼容前缀，就像webkit-xxx之类的一样。</p>
<h4 id="13npm和nodejs又是什么它们是什么关系">13.NPM和Node.js又是什么？它们是什么关系？</h4>
<p>首先讲讲Node.js。我们知道通常情况下，JavaScript的运行环境都是浏览器，因此JavaScript的能力也就局限于浏览器能赋予它的权限了。比如说读写本地系统文件这种操作，一般情况下运行在浏览器中的JavaScript代码是没有这个操作权限的。如果我们想用JavaScript写出一些能够运行在操作系统上的，能够具有像PHP，JAVA之类的编程语言具有的功能的程序该怎么办呢？Node.js就解决了这个问题。Node.js是一个服务端的JavaScript运行环境，通过Node.js可以实现用JavaScript写独立程序。像我们之前提到的Webpack就是Node.js写的，所以作为一个前端开发，即使你不用Node.js写独立程序，也得配一个Node.js运行环境，毕竟很多前端工具都是使用它写的。</p>
<p>NPM是一个node.js的包管理器。我们在传统开发的时候，JQuery.js大多都是百度搜索，然后去官网下载，或者直接引入CDN资源，这种方法太过于麻烦。如果以后遇到其他的包，这个包的代码本身可能还调用了其他的包（也称这个包和其他的那几个包存在依赖关系），那么我们要在自己的项目中引入一个包将变得十分困难。现在我们有了NPM这个包管理器，直接可以通过</p>
<p>npm install xxx包名称<br>
的方式引入它，比如说</p>
<p>npm install vue<br>
就自动在当前项目文件夹下导入了这个包，并且npm自动下载好了vue这个包依赖的其他包。</p>
<p>至于有的人在按照网上的npm教程配置的时候踩坑了，发现下载速度很慢或者完全下载不了，那是因为我国有着众所周知的原因，网上也有各种解决方法可以解决这个问题，大家多善用搜索引擎。</p>
<p>前面提到了Webpack可以安装各种插件来扩展功能，其实也是通过这种方式扩展。</p>
<p>如果你学过PHP的话，NPM就和PHP里面的Composer差不多。也和CentOS下的yum和Ubuntu下的apt-get差不多。</p>
<h4 id="14vue-cli又是啥">14.Vue-CLi又是啥？</h4>
<p>它是一个vue.js的脚手架工具。说白了就是一个自动帮你生成好项目目录，配置好Webpack，以及各种依赖包的工具，它可以通过</p>
<p>npm install vue-cli -g<br>
的方式安装，后面的-g表示全局安装的意思，意味着你可以打开命令行之后直接通过vue命令调用它。</p>
<h4 id="15我该不该学vuejs">15.我该不该学Vue.js？</h4>
<p>现在Vue.js无论是发展势头还是作者支持还是很好的，而且它本身中文资料就比较多，教程也很多，现在随随便便打开几个和前端开发有关的知乎专栏，基本上都能见到相关文章，社区也很活跃。</p>
<p>至于你该不该学，取决于你自己，如果你当前只是做做以内容展示为主的项目，或者就是成天用各种CMS建站仿站，并且以后都不打算更换更好的工作，那么可以暂时不用学。如果你开发的项目交互非常多，而且前后端开发都对前后端分离有很清楚的认识，那么可以大胆的学习，并且在实际项目中运用。</p>
<h4 id="16vuejs怎么火起来的">16.Vue.js怎么火起来的？</h4>
<p>关于这个问题，网上说法很多，我自己认为主要还是前些年大前端变革太快，而最近一年开始Vue.js+Webpack这个组合开始逐渐稳定下来了，而且已经有了很多中文资料。</p>
<p>对比它的竞争对手AngularJS，新旧版本项目无法平滑升级，变革太大让用户感觉不安稳。</p>
<p>而React本身主流推荐用的是JSX，需要额外学习一门语法（什么？学Vue.js还要学ECMAScript6？现在ECMAScript6是趋势，并不是因为Vue.js才要学的），并且React本身用的是render写法编写模版代码，这让很多用习惯了Smarty等后端模版引擎得人来使用感觉很不适应，现在看来React本身在中国一些论坛社区的火爆程度还是没有Vue.js高。</p>
<p>当然也并不是说除了Vue.js以外其他框架都很差。像知乎新版也是用React开发的，他还是有各自优秀的地方大家可以深入学习之后做出自己的判断。</p>
<h4 id="17我在很多地方还看到vuex和vue-route它们又是什么">17.我在很多地方还看到Vuex和Vue-route，它们又是什么？</h4>
<p>Vuex是vue的一个状态管理器。用于集中管理一个单页应用程序中的各种状态。</p>
<p>Vue-route是vue的一个前端路由器，这个路由器不是我们上网用的路由器，而是一个管理请求入口和页面映射关系的东西。它可以实现对页面局部进行无刷新的替换，让用户感觉就像切换到了网页一样。</p>
<p>要讲清楚这两个东西，又得花费大量篇幅，所以这里只是简单提一下，先学好vue.js本身才是最重要的。</p>
<h4 id="18我还在一些地方看到过vue-resource和axios它们又是什么">18.我还在一些地方看到过Vue-resource和Axios，它们又是什么？</h4>
<p>我们在传统的前后端不分离的开发中，后端直接把数据通过模版引擎拼接进了返回的HTML中。而现在做单页应用程序属于前后端分离开发，那么这个单页应用程序中的数据就得通过ajax的方式获取，也要通过ajax的方式提交到后端。</p>
<p>在传统开发中我们都是通过xmlhttprequest手动操作，或者通过JQuery的ajax方法来进行数据提交获取。</p>
<p>vue.js本身没有封装ajax操作库，所以我们要通过Vue-resource和Axios来进行ajax操作，而因为种种原因，现在vue.js2.0已经将axios作为官方推荐的ajax库了。</p>
<h4 id="19我该学vuejs20还是10呢">19.我该学Vue.js2.0还是1.0呢？</h4>
<p>现在很多框架和语言都是学新不学旧（Python慢慢也变得如此），因此如果不是为了维护老旧项目，肯定推荐学Vue.js2.0。而且学会了Vue.js2.0，再去学习Vue.js1.0也不是什么难事。</p>
<h4 id="20写vuejs用什么开发工具和电脑呢">20.写Vue.js用什么开发工具和电脑呢？</h4>
<p>前端开发基本上不需要太高端的电脑都能胜任，现在这个时代是台电脑，装个编辑器都可以做前端开发的。</p>
<p>Vue.js的组件文件本质上还是普通的代码文件，所以各种编辑器配合一些语法检查插件就足够了。我自己用的是sublime text 3，安装一些插件之后可以实现.vue单文件组件高亮代码以及各种自动完成。Webstorm中也有类似插件，大家可以在网上各种教学文章的指导下配置好环境。</p>
<p>我用的主题是Monokai，这个主题在大部分显示器下长时间观看眼睛不会很疼。我使用的显示器是LG IPS236，部分显示器有亮度色标调节，我这款显示器调到2.0左右会比较舒适，过低会导致底部的茶色背景变黑，反差较大更加疲劳，过高会导致对比度不足，画面泛白影响调色。</p>
<p>结语：</p>
<p>可能包括我在内的很多人在看到Vue.js那神奇的双向绑定优雅写法都会有一种非常惊艳，而看到中文文档发布之后有种想立马学习的冲动。可惜大前端终究是大前端，如果一个对于前端各个方面没有深入认识就想着能一步登天，肯定对不起大前端的“大”字。原本看着只想学一个Vue.js，没想到顺带把ECMAScript6，Webpack配置，ESLint配置，bable配置，npm使用，node.js语法，以后vue全家桶中的vuex，vue-route等等等等都学了一遍。前段时间网上也流传出了一个职位叫做Webpack配置工程师，从这里也可以看出弄懂前端这个大杂烩确实不是那么容易。大家一起加油，有什么问题也可以在评论区回复，我会抽空补充在文章内容中。谢谢各位的支持！~</p>
<p>作者：晴天Smile<br>
来源：CSDN<br>
原文：https://blog.csdn.net/liang377122210/article/details/71545459<br>
版权声明：本文为博主原创文章，转载请附上博文链接！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[centos 7安装gnome]]></title>
        <id>https://herryle.github.io/centos-7/</id>
        <link href="https://herryle.github.io/centos-7/">
        </link>
        <updated>2020-02-26T07:14:55.000Z</updated>
        <content type="html"><![CDATA[<p>GNOME是一套纯粹自由的计算机软件，运行在操作系统上，提供图形桌面环境。</p>
<p>GNOME 包含了 Panel （用来启动此程式和显示目前的状态）、桌面 （应用程式和资料放置的地方）及一系列的标准桌面工具和应用程式，并且能让各个应用程式都能正常地运作。</p>
<p>GNOME是Linux操作系统上最常用的图形桌面环境之一。</p>
<p>​       VNC基本上是由两部分组成：一部分是客户端的应用程序(vncviewer)；另外一部分是服务器端的应用程序(vncserver)。VNC的基本运行原理和一些Windows下的远程控制软件很相像。VNC的服务器端应用程序在UNIX和Linux操作系统中适应性很强，图形用户界面十分友好，看上去和Windows下的软件界面也很类似。在任何安装了客户端的应用程序(vncviewer)的Linux平台的计算机都能十分方便地和安装了服务器端的应用程序(vncserver)的计算机相互连接。另外，服务器端 (vncserver)还内建了Java Web接口，这样用户通过服务器端对其他计算机的操作就能通过Netscape显示出来了，这样的操作过程和显示方式比较直观方便。</p>
<p>在CentOS7上面安装步骤如下</p>
<ol>
<li>
<p>安装宝塔面板（方便在接下来步骤中进行配置文档的编辑和监控系统）</p>
<pre><code class="language-shell">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh
</code></pre>
</li>
<li>
<p>安装GNOME</p>
<pre><code class="language-shell">yum groupinstall &quot;GNOME Desktop&quot; &quot;Graphical Administration Tools&quot;
</code></pre>
</li>
</ol>
<p>安装包大概在800M左右 ，选择y进行安装。</p>
<p>出现complete则表示安装成功</p>
<p>启动GNOME桌面</p>
<pre><code class="language-shell">startx
</code></pre>
<ol>
<li>安装VNCServer</li>
</ol>
<pre><code class="language-shell">安装
#yum -y install tigervnc-server
配置
#cp /lib/systemd/system/vncserver@.service /etc/systemd/system/vncserver@:1.service
设置VNC密码
#vncpasswd
重启systemd
#systemctl daemon-reload
设置永久开启VNC服务
#systemctl enable vncserver@:1.service
启动VNC服务
#systemctl start vncserver@:1.service
如遇报错：
Job for vncserver@:1.service failed because the control process exited with error code. See &quot;systemctl status vncserver@:1.service&quot; and &quot;journalctl -xe&quot; for details.
编辑/etc/systemd/system/vncserver@:1.service配置文件：
将Type=forking改为Type=simple
重新启动VNC服务
#systemctl restart vncserver@:1.service

查看VNC服务状态
#systemctl status vncserver@:1.service
如有Activie:failed则表示启动失败
编辑/etc/systemd/system/vncserver@:1.service配置文件：
将里面所有的&lt;USER&gt;替换为当前用户名(大致有两处)，如root；另，如果是root用户，应将PIDFile的/home/root改为/root
重新启动VNC服务
这里可能会遇到错误，当执行start vncserver@:1.service时可能提示如下错误。
Job for vncserver@:1.service failed because the control process exited with error code. See 
&quot;systemctl status vncserver@:1.service&quot; and &quot;journalctl -xe&quot; for details.
解决办法
删除/tmp/.X11-unix/ 目录，再启用一次即可
# \rm -R /tmp/.X11-unix/
#systemctl restart vncserver@:1.service

</code></pre>
<ol start="4">
<li>VNC客户端连接</li>
</ol>
<blockquote>
<ul>
<li>VNC远程服务端需开放5901端口</li>
<li>客户端安装VNC Viewer或TigerVNC</li>
<li>连接地址填写ip:5901</li>
<li>然后输入所设置的VNC密码</li>
</ul>
</blockquote>
<p>end！！！！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Vue+Node.js+Mongoodb开发完整的前后端项目]]></title>
        <id>https://herryle.github.io/33/</id>
        <link href="https://herryle.github.io/33/">
        </link>
        <updated>2020-02-25T13:53:18.000Z</updated>
        <content type="html"><![CDATA[<h2 id="项目简介">项目简介</h2>
<p>前一段时间领导临时给了一个小需求，要做一个简单的会议报表，要满足会议表格内容的增删改查、文件的上传下载以及用户登录验证，于是趁着划水的时间写了一下，看着网上针对这一块的教程不是很多，所以写下了这篇文章，也算是入门全栈开发的一篇基础文章，大佬勿喷。</p>
<p>以下是项目地址，希望给个⭐️ <code>star</code>⭐️，鼓励一下：</p>
<p><a href="https://github.com/herryle/vue-fight-direct">github地址</a></p>
<p>效果预览：</p>
<figure data-type="image" tabindex="1"><img src="https://s2.ax1x.com/2019/12/31/l37qmt.gif" alt="l37qmt.gif" loading="lazy"></figure>
<h2 id="技术栈">技术栈</h2>
<p>项目前端基于Vue，后端基于Nodejs-Express，数据库采用Mongodb。</p>
<h2 id="前端">前端</h2>
<p>主要是基于 <code>Vue-Cli</code></p>
<p>UI 框架选的是:element-ui</p>
<p>css采用 <code>scss</code></p>
<p>登录页的用的是element-ui的表单组件，没有单独写页面，原谅我的懒。。。</p>
<p>前端就不过多介绍了，也就是老一套，具体的可以看代码。</p>
<p>项目结构（大致）如下：</p>
<pre><code>├── pulic         
│   └── index.html 
├── src
│   ├── assets   
│   ├── components    // 主组件    
│   └── plugin       // element插件
│   └── App.vue      
│   └──http.js       // 对 axios进行 二次封装
│   └── main.js       
├── .env              // 环境变量配置文件
</code></pre>
<p><strong>Tip：</strong> 结构很简单，主要是axios封装，组件element+bootstrap。</p>
<h2 id="后端">后端</h2>
<p>后端采用Nodejs，框架采用的Express，这个可以根据个人兴趣来，Koa,nestjs，Hapi都可。不做过多评价。</p>
<p>后端项目当中用到的第三方库，主要是列一下最主要的。</p>
<pre><code class="language-json">  &quot;dependencies&quot;: {
     // 加密用户密码（数据库没有存明文密码）这里强调提下windows最好用bcryptjs,mac可以用bcrypt。
    &quot;bcryptjs&quot;: &quot;^2.4.3&quot;,
     //解决跨域
    &quot;cors&quot;: &quot;^2.8.5&quot;,
      //这里用的是express下一版本
    &quot;express&quot;: &quot;^5.0.0-alpha.7&quot;,
      //
    &quot;http-assert&quot;: &quot;^1.4.1&quot;,
      //目前最流行的跨域认证
    &quot;jsonwebtoken&quot;: &quot;^8.5.1&quot;,
      //一款为异步工作环境设计的 MongoDB 对象建模工具
    &quot;mongoose&quot;: &quot;^5.7.13&quot;,
    &quot;morgan&quot;: &quot;^1.9.1&quot;,
      //express 中间件 上传下载文档
    &quot;multer&quot;: &quot;^1.4.2&quot;,
  }
</code></pre>
<p>后端的项目结构如下，这是自己搭建的，最好还是按照规范来。</p>
<pre><code>│   ├── middleware// 自定义中间件目录
│   ├── models    //定义的表结构
│   ├── plugin    // 数据库配置文件
│   │    
│   ├── routes    // 路由文件
│   │   
│   └── uploads    // 文件上传目录
│   │  
├── index.js        // 项目入口文件

</code></pre>
<h2 id="数据库">数据库</h2>
<p>数据库这里采用的是mongodb，具体的就不过多介绍了。</p>
<p>表结构如下：</p>
<p>表单数据模型</p>
<pre><code class="language-js">const mongoose = require('mongoose')
//创建模型
const schema = new mongoose.Schema({
  date: { type: Date },
  iteminfo: [
    {
      road_name: { type: String },
      road_lat: { type: Number },
      road_lng: { type: Number },
      ys_state: { type: String },
      ws_state: { type: String },
      issus_list: { type: String },
      list_before_url: [{ name: { type: String }, url: { type: String } }],
      list_after_url: [{ name: { type: String }, url: { type: String } }],
      remark: { type: String }
    }
  ]
})

//导出模型
module.exports = mongoose.model('FightInfo', schema)
</code></pre>
<p>用户模型</p>
<pre><code class="language-js">const mongoose = require('mongoose')

const schema = new mongoose.Schema({
  username: { type: String },
  password: {
    type: String,
    set(val) {
      return require('bcryptjs').hashSync(val, 10)
    }
  }
})

module.exports = mongoose.model('User', schema)

</code></pre>
<p><strong>Tip:</strong> 表结构很简单，两张表结构模型都在model文件夹下面</p>
<h2 id="前后端分离">前后端分离</h2>
<p>项目采用前后端分离的方式进行开发,Express提供API接口，进行访问过滤（路由）、验证（JSON-WEB-TOKEN）以及mongoose操作mongoodb数据库的一些知识和技巧。</p>
<ol>
<li>
<p>启动Express 主文件如下</p>
<pre><code class="language-js">const express = require('express')
const logger = require('morgan')
const app = express()

//请求logger  便于调试
app.use(logger('dev'))
//支持json
app.use(express.json())
//解决跨域
app.use(require('cors')())

//静态文件夹 上传下载文件
app.use('/uploads', express.static(__dirname + '/uploads'))
//静态文件夹
app.use('/json', express.static(__dirname + '/plugin/json'))

//连接数据库文件
require('./plugin/db/config')(app)
//表单的具体操作方法
require('./routes/fightinfo')(app)
//用户登录验证
require('./routes/user')(app)


app.use(async (err, req, res, next) =&gt; {
  res.status(err.statusCode || 500).send({
    message: err.message
  })
})

app.listen(3001, () =&gt; {
  console.log('http://127.0.0.1:3001/')
})
</code></pre>
</li>
<li>
<p>数据库连接</p>
<pre><code class="language-js">//mongodb数据库配置连接
module.exports = app =&gt; {
  const mongoose = require('mongoose')
  mongoose.connect('mongodb://localhost/vue-fight-direct', {
    useNewUrlParser: true,
    useUnifiedTopology: true,
    useFindAndModify: false
  })
}
</code></pre>
</li>
<li>
<p>编写用户验证的路由</p>
<p><strong>Tip:</strong> <strong><em>这里是用户登录注册的路由，由于没有写注册页面（我这里只是为了实现一个交互功能，好像是为了我的懒找借口。。），大家可以用第三方工具PostMan进行注册验证，字段可以根据用户模型来即可，也就是（username，password）。如果不注册的话 数据增删改查都不行，需要进行登录验证。</em>。</strong></p>
<pre><code class="language-js">module.exports = app =&gt; {
  const express = require('express')
  const router = express.Router()
  const jwt = require('jsonwebtoken')
  const bcryptjs = require('bcryptjs')
  //引入用户模型文件
  const User = require('../../models/User')
  app.set('secret', 'ashjhdjhasjdidh')
    //用户登录
  router.post('/login', async (req, res) =&gt; {
    const { username, password } = req.body
    //判断用户是否存在
    const user = await User.findOne({ username })
    if (!user) {
      return res.status(422).send({
        message: '用户不存在'
      })
    }
    //判断密码是否正确
    const isValid = bcryptjs.compareSync(password, user.password)
    if (!isValid) {
      return res.status(422).send({
        message: '密码错误'
      })
    }
    //发送token
    const token = jwt.sign({ id: user._id }, app.get('secret'))
    res.send({ token: token, message: '登陆成功' })
  })
   
  //用户注册
  router.post('/register', async (req, res) =&gt; {
    const model = await User.create(req.body)
    res.send(model)
  })

  app.use('/api/rest/user', router)
}

</code></pre>
</li>
<li>
<p>编写表单具体操作(CRUD)路由</p>
<pre><code class="language-js">module.exports = app =&gt; {
  const express = require('express')
  const multer = require('multer')
  const FightInfo = require('../../models/FightInfo')
  const router = express.Router({
    mergeParams: true
  })

  const storage = multer.diskStorage({
    destination: (req, file, cb) =&gt; {
      cb(null, './uploads')
    },
    filename: (req, file, cb) =&gt; {
      cb(null, file.originalname)
    }
  })
  const upload = multer({
    storage: storage
  })

  //用户验证中间件
  const authMiddleWare = require('../../middleware/auth')

  //添加表单
  router.post('/', authMiddleWare(), async (req, res) =&gt; {
    await FightInfo.create(req.body)
    res.send({ message: '表单成功添加' })
  })

  //修改表单信息
  router.put('/:id', authMiddleWare(), async (req, res) =&gt; {
    await FightInfo.findByIdAndUpdate(req.params.id, req.body)
    res.send({ message: '保存成功' })
  })

  //获取单个表单
  router.get('/:id', async (req, res) =&gt; {
    const items = await FightInfo.findById(req.params.id)
    res.send(items)
  })

  //获取所有表单
  router.get('/', async (req, res) =&gt; {
    const items = await FightInfo.find().sort({ date: -1 })
    res.send(items)
  })

  //文件上传
  app.post('/api/rest/upload', upload.single('file'), async (req, res) =&gt; {
    req.file.url = `http://localhost:3001/uploads/${req.file.filename}`
    await res.send(req.file)
  })

  app.use('/api/rest/fightinfo', router)
}

</code></pre>
</li>
<li>
<p>用户验证中间件</p>
<pre><code class="language-js">module.exports = options =&gt; {
  return async (req, res, next) =&gt; {
    const jwt = require('jsonwebtoken')
    const token = String(req.headers.authorization || '').split(' ').pop()
    //判断有无token
    if (!token) {
      return res.status(401).send({
        message: '无效的token'
      })
    }
    //判断用户是否存在
    const userid = jwt.verify(token, req.app.get('secret')).id
    if (!userid) {
      return res.status(401).send({
        message: '用户不存在'
      })
    }
    next()
  }
}

</code></pre>
</li>
</ol>
<h2 id="项目详述">项目详述</h2>
<p><strong>新增表单</strong></p>
<p>用户可以选择新的表单进行会议记录，但是前提必须是要登录，才有权限。</p>
<p><em><strong>用户初次登录的时候并没有表单信息，可以选择新增表单进行添加内容。</strong></em></p>
<p><strong>新增作战对象</strong></p>
<p>用户可以选择在表单中新增单个对象进行会议记录，这里不需要登录，但是保存还是需要权限认证。</p>
<p><strong>登录</strong></p>
<p>用户登录认证，前端登录后台返回token，存入session中，保存和新增操作都需要进行认证。</p>
<p><strong>其他功能</strong></p>
<p>表单中可以进行内容编辑，每次编辑过后要进行保存入库，也可以进行上传文件和下载。</p>
<p><strong>不足</strong></p>
<p>上传文件和下载  这里没有进行权限认证，也就是不登录也可以上传，当然也可以加上具体的权限认证可以参照element-ui中组件上传，这里就不做过多的赘述了。</p>
<h2 id="总结">总结</h2>
<p>其实整个项目很简单，无非就是增删改查，但是这也算是一个完整的全栈实战了，其中也包括用户登录注册，接口权限验证等。技术栈（Vue、Express、mongodb）也都是比较火的，对于初学者还是很有意义的。</p>
<p>希望你不吝赐教，可以的话给颗⭐️ <code>star</code>⭐️ 鼓励一下吧：</p>
<p><a href="https://github.com/herryle/vue-fight-direct">github地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS使用小技巧总结]]></title>
        <id>https://herryle.github.io/M1VcEne1-/</id>
        <link href="https://herryle.github.io/M1VcEne1-/">
        </link>
        <updated>2020-01-01T07:47:09.000Z</updated>
        <content type="html"><![CDATA[<h3 id="目录">目录</h3>
<ul>
<li>「String Skill」：字符串技巧</li>
<li>「Number Skill」：数值技巧</li>
<li>「Boolean Skill」：布尔技巧</li>
<li>「Array Skill」：数组技巧</li>
<li>「Object Skill」：对象技巧</li>
<li>「Function Skill」：函数技巧</li>
<li>「DOM Skill」：DOM技巧</li>
</ul>
<p>备注</p>
<ul>
<li>代码只作演示用途，不会详细说明ES6语法</li>
<li>如有不明白的语法问题请参考阮一峰老师的《ES6标准入门》</li>
<li>《ES6标准入门》一直保持更新，建议收藏，平时查看</li>
</ul>
<h3 id="string-skill">String Skill</h3>
<h5 id="对比时间">对比时间</h5>
<blockquote>
<p>❝</p>
<p>时间个位数形式需补0</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const time1 = &quot;2019-02-14 21:00:00&quot;;
const time2 = &quot;2019-05-01 09:00:00&quot;;
const overtime = time1 &gt; time2;
// overtime =&gt; false
</code></pre>
<h5 id="格式化金钱">格式化金钱</h5>
<pre><code class="language-js">const ThousandNum = num =&gt; num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, &quot;,&quot;);
const money = ThousandNum(20190214);
// money =&gt; &quot;20,190,214&quot;
</code></pre>
<h5 id="生成随机idjs">生成随机IDjs</h5>
<pre><code class="language-js">const RandomId = len =&gt;Math.random().toString(36).substr(3, len);
const id = RandomId(10);
// id =&gt; &quot;jg7zpgiqva&quot;
</code></pre>
<h5 id="生成随机hex色值">生成随机HEX色值</h5>
<pre><code class="language-js">const RandomColor = () =&gt;&quot;#&quot; + Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, &quot;0&quot;);
const color = RandomColor();
// color =&gt; &quot;#f03665&quot;
</code></pre>
<h5 id="生成星级评分">生成星级评分</h5>
<pre><code class="language-js">const StartScore = rate =&gt;&quot;★★★★★☆☆☆☆☆&quot;.slice(5 - rate, 10 - rate);
const start = StartScore(3);
// start =&gt; &quot;★★★&quot;
</code></pre>
<h5 id="操作url查询参数">操作URL查询参数</h5>
<pre><code class="language-js">const params = new URLSearchParams(location.search.replace(/\?/ig, &quot;&quot;)); // location.search = &quot;?name=young&amp;sex=male&quot;
params.has(&quot;young&quot;); // true
params.get(&quot;sex&quot;); // &quot;male&quot;
</code></pre>
<h3 id="number-skill">Number Skill</h3>
<h5 id="取整">取整</h5>
<blockquote>
<p>❝</p>
<p>代替正数的<code>Math.floor()</code>，代替负数的<code>Math.ceil()</code></p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const num1 = ~~ 1.69;
const num2 = 1.69 | 0;
const num3 = 1.69 &gt;&gt; 0;
// num1 num2 num3 =&gt; 1 1 1
</code></pre>
<h5 id="补零">补零</h5>
<pre><code>const FillZero = (num, len) =&gt; num.toString().padStart(len, &quot;0&quot;);
const num = FillZero(169, 5);
// num =&gt; &quot;00169&quot;
</code></pre>
<h5 id="转数值">转数值</h5>
<blockquote>
<p>❝</p>
<p>只对<code>null、&quot;&quot;、false、数值字符串</code>有效</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const num1 = +null;
const num2 = +&quot;&quot;;
const num3 = +false;
const num4 = +&quot;169&quot;;
// num1 num2 num3 num4 =&gt; 0 0 0 169
</code></pre>
<h5 id="时间戳">时间戳</h5>
<pre><code class="language-js">const timestamp = +newDate(&quot;2019-02-14&quot;);
// timestamp =&gt; 1550102400000
</code></pre>
<h5 id="精确小数">精确小数</h5>
<pre><code class="language-js">const RoundNum = (num, decimal) =&gt;Math.round(num * 10 ** decimal) / 10 ** decimal;
const num = RoundNum(1.69, 1);
// num =&gt; 1.7
</code></pre>
<h5 id="判断奇偶">判断奇偶</h5>
<pre><code class="language-js">const OddEven = num =&gt; !!(num &amp; 1) ? &quot;odd&quot; : &quot;even&quot;;
const num = OddEven(2);
// num =&gt; &quot;even&quot;
</code></pre>
<h5 id="取最小最大值">取最小最大值</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
const min = Math.min(...arr);
const max = Math.max(...arr);
// min max =&gt; 0 2
</code></pre>
<h5 id="生成范围随机数">生成范围随机数</h5>
<pre><code class="language-js">const RandomNum = (min, max) =&gt;Math.floor(Math.random() * (max - min + 1)) + min;
const num = RandomNum(1, 10);
</code></pre>
<h3 id="boolean-skill">Boolean Skill</h3>
<h5 id="短路运算符">短路运算符</h5>
<pre><code class="language-js">const a = d &amp;&amp; 1; // 满足条件赋值：取假运算，从左到右依次判断，遇到假值返回假值，后面不再执行，否则返回最后一个真值
const b = d || 1; // 默认赋值：取真运算，从左到右依次判断，遇到真值返回真值，后面不再执行，否则返回最后一个假值
const c = !d; // 取假赋值：单个表达式转换为true则返回false，否则返回true
</code></pre>
<h5 id="判断数据类型">判断数据类型</h5>
<blockquote>
<p>❝</p>
<p>可判断类型：undefined、null、string、number、boolean、array、object、symbol、date、regexp、function、asyncfunction、arguments、set、map、weakset、weakmap</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">function DataType(tgt, type) {
    const dataType = Object.prototype.toString.call(tgt).replace(/\[object (\w+)\]/, &quot;$1&quot;).toLowerCase();
    return type ? dataType === type : dataType;
}
DataType(&quot;young&quot;); // &quot;string&quot;
DataType(20190214); // &quot;number&quot;
DataType(true); // &quot;boolean&quot;
DataType([], &quot;array&quot;); // true
DataType({}, &quot;array&quot;); // false
</code></pre>
<h5 id="是否为空数组">是否为空数组</h5>
<pre><code class="language-js">const arr = [];
const flag = Array.isArray(arr) &amp;&amp; !arr.length;
// flag =&gt; true
</code></pre>
<h5 id="是否为空对象">是否为空对象</h5>
<pre><code class="language-js">const obj = {};
const flag = DataType(obj, &quot;object&quot;) &amp;&amp; !Object.keys(obj).length;
// flag =&gt; true
</code></pre>
<h5 id="满足条件时执行">满足条件时执行</h5>
<pre><code class="language-js">const flagA = true; // 条件A
const flagB = false; // 条件B
(flagA || flagB) &amp;&amp; Func(); // 满足A或B时执行
(flagA || !flagB) &amp;&amp; Func(); // 满足A或不满足B时执行
flagA &amp;&amp; flagB &amp;&amp; Func(); // 同时满足A和B时执行
flagA &amp;&amp; !flagB &amp;&amp; Func(); // 满足A且不满足B时执行
</code></pre>
<h5 id="为非假值时执行">为非假值时执行</h5>
<pre><code class="language-js">const flag = false; // undefined、null、&quot;&quot;、0、false、NaN
!flag &amp;&amp; Func();
</code></pre>
<h5 id="数组不为空时执行">数组不为空时执行</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
arr.length &amp;&amp; Func();
</code></pre>
<h5 id="对象不为空时执行">对象不为空时执行</h5>
<pre><code class="language-js">const obj = { a: 0, b: 1, c: 2 };
Object.keys(obj).length &amp;&amp; Func();
</code></pre>
<h5 id="函数退出代替条件分支退出">函数退出代替条件分支退出</h5>
<pre><code class="language-js">if (flag) {
    Func();
    returnfalse;
}
// 换成
if (flag) {
    return Func();
}
</code></pre>
<h5 id="switchcase使用区间">switch/case使用区间</h5>
<pre><code class="language-js">const age = 26;
switch (true) {
    caseisNaN(age):
        console.log(&quot;not a number&quot;);
        break;
    case (age &lt; 18):
        console.log(&quot;under age&quot;);
        break;
    case (age &gt;= 18):
        console.log(&quot;adult&quot;);
        break;
    default:
        console.log(&quot;please set your age&quot;);
        break;
}
</code></pre>
<h3 id="array-skill">Array Skill</h3>
<h5 id="克隆数组">克隆数组</h5>
<pre><code class="language-js">const _arr = [0, 1, 2];
const arr = [..._arr];
// arr =&gt; [0, 1, 2]
</code></pre>
<h5 id="合并数组">合并数组</h5>
<pre><code class="language-js">const arr1 = [0, 1, 2];
const arr2 = [3, 4, 5];
const arr = [...arr1, ...arr2];
// arr =&gt; [0, 1, 2, 3, 4, 5];
</code></pre>
<h5 id="去重数组">去重数组</h5>
<pre><code class="language-js">const arr = [...new Set([0, 1, 1, null, null])];
// arr =&gt; [0, 1, null]
</code></pre>
<h5 id="混淆数组">混淆数组</h5>
<pre><code class="language-js">const arr = [0, 1, 2, 3, 4, 5].slice().sort(() =&gt;Math.random() - .5);
// arr =&gt; [3, 4, 0, 5, 1, 2]
</code></pre>
<h5 id="清空数组">清空数组</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
arr.length = 0;
// arr =&gt; []
</code></pre>
<h5 id="截断数组">截断数组</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
arr.length = 2;
// arr =&gt; [0, 1]
</code></pre>
<h5 id="交换赋值">交换赋值</h5>
<pre><code class="language-js">let a = 0;
let b = 1;
[a, b] = [b, a];
// a b =&gt; 1 0
</code></pre>
<h5 id="过滤空值">过滤空值</h5>
<blockquote>
<p>❝</p>
<p>空值：undefined、null、&quot;&quot;、0、false、NaN</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const arr = [undefined, null, &quot;&quot;, 0, false, NaN, 1, 2].filter(Boolean);
// arr =&gt; [1, 2]
</code></pre>
<h5 id="异步累计">异步累计</h5>
<pre><code class="language-js">asyncfunction Func(deps) {
    return deps.reduce(async(t, v) =&gt; {
        const dep = await t;
        const version = await Todo(v);
        dep[v] = version;
        return dep;
    }, Promise.resolve({}));
}
const result = await Func(); // 需在async包围下使用
</code></pre>
<h5 id="数组首部插入成员">数组首部插入成员</h5>
<pre><code class="language-js">let arr = [1, 2]; // 以下方法任选一种
arr.unshift(0);
arr = [0].concat(arr);
arr = [0, ...arr];
// arr =&gt; [0, 1, 2]
</code></pre>
<h5 id="数组尾部插入成员">数组尾部插入成员</h5>
<pre><code class="language-js">let arr = [0, 1]; // 以下方法任选一种
arr.push(2);
arr.concat(2);
arr[arr.length] = 2;
arr = [...arr, 2];
// arr =&gt; [0, 1, 2]
</code></pre>
<h5 id="统计数组成员个数">统计数组成员个数</h5>
<pre><code class="language-js">const arr = [0, 1, 1, 2, 2, 2];
const count = arr.reduce((t, v) =&gt; {
	t[v] = t[v] ? ++t[v] : 1;
	return t;
}, {});
// count =&gt; { 0: 1, 1: 2, 2: 3 }
</code></pre>
<h5 id="解构数组成员嵌套">解构数组成员嵌套</h5>
<pre><code class="language-js">const arr = [0, 1, [2, 3, [4, 5]]];
const [a, b, [c, d, [e, f]]] = arr;
// a b c d e f =&gt; 0 1 2 3 4 5
</code></pre>
<h5 id="解构数组成员别名">解构数组成员别名</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
const { 0: a, 1: b, 2: c } = arr;
// a b c =&gt; 0 1 2
</code></pre>
<h5 id="解构数组成员默认值">解构数组成员默认值</h5>
<pre><code class="language-js">const arr = [0, 1, 2];
const [a, b, c = 3, d = 4] = arr;
// a b c d =&gt; 0 1 2 4
</code></pre>
<h5 id="获取随机数组成员">获取随机数组成员</h5>
<pre><code class="language-js">const arr = [0, 1, 2, 3, 4, 5];
const randomItem = arr[Math.floor(Math.random() * arr.length)];
// randomItem =&gt; 1
</code></pre>
<h5 id="创建指定长度数组">创建指定长度数组</h5>
<pre><code class="language-js">const arr = [...new Array(3).keys()];
// arr =&gt; [0, 1, 2]
</code></pre>
<h5 id="创建指定长度且值相等的数组">创建指定长度且值相等的数组</h5>
<pre><code class="language-js">const arr = newArray(3).fill(0);
// arr =&gt; [0, 0, 0]
</code></pre>
<h5 id="reduce代替map和filter">reduce代替map和filter</h5>
<pre><code class="language-js">const _arr = [0, 1, 2];

// map
const arr = _arr.map(v =&gt; v * 2);
const arr = _arr.reduce((t, v) =&gt; {
    t.push(v * 2);
    return t;
}, []);
// arr =&gt; [0, 2, 4]

// filter
const arr = _arr.filter(v =&gt; v &gt; 0);
const arr = _arr.reduce((t, v) =&gt; {
    v &gt; 0 &amp;&amp; t.push(v);
    return t;
}, []);
// arr =&gt; [1, 2]

// map和filter
const arr = _arr.map(v =&gt; v * 2).filter(v =&gt; v &gt; 2);
const arr = _arr.reduce((t, v) =&gt; {
    v = v * 2;
    v &gt; 2 &amp;&amp; t.push(v);
    return t;
}, []);
// arr =&gt; [4]
</code></pre>
<h3 id="object-skill">Object Skill</h3>
<h5 id="克隆对象">克隆对象</h5>
<pre><code class="language-js">const _obj = { a: 0, b: 1, c: 2 }; // 以下方法任选一种
const obj = { ..._obj };
const obj = JSON.parse(JSON.stringify(_obj));
// obj =&gt; { a: 0, b: 1, c: 2 }
</code></pre>
<h5 id="合并对象">合并对象</h5>
<pre><code class="language-js">const obj1 = { a: 0, b: 1, c: 2 };
const obj2 = { c: 3, d: 4, e: 5 };
const obj = { ...obj1, ...obj2 };
// obj =&gt; { a: 0, b: 1, c: 3, d: 4, e: 5 }
</code></pre>
<h5 id="对象字面量">对象字面量</h5>
<blockquote>
<p>❝</p>
<p>获取环境变量时必用此方法，用它一直爽，一直用它一直爽</p>
<p>❞</p>
</blockquote>
<pre><code>const env = &quot;prod&quot;;
const link = {
    dev: &quot;Development Address&quot;,
    test: &quot;Testing Address&quot;,
    prod: &quot;Production Address&quot;
}[env];
// link =&gt; &quot;Production Address&quot;
</code></pre>
<h5 id="对象变量属性">对象变量属性</h5>
<pre><code class="language-js">const flag = false;
const obj = {
    a: 0,
    b: 1,
    [flag ? &quot;c&quot; : &quot;d&quot;]: 2
};
// obj =&gt; { a: 0, b: 1, d: 2 }
</code></pre>
<h5 id="创建纯空对象">创建纯空对象</h5>
<pre><code class="language-js">const obj = Object.create(null);
Object.prototype.a = 0;
// obj =&gt; {}
</code></pre>
<h5 id="删除对象无用属性">删除对象无用属性</h5>
<pre><code class="language-js">const obj = { a: 0, b: 1, c: 2 }; // 只想拿b和c
const { a, ...rest } = obj;
// rest =&gt; { b: 1, c: 2 }
</code></pre>
<h5 id="解构对象属性嵌套">解构对象属性嵌套</h5>
<pre><code class="language-js">const obj = { a: 0, b: 1, c: { d: 2, e: 3 } };
const { c: { d, e } } = obj;
// d e =&gt; 2 3
</code></pre>
<h5 id="解构对象属性别名">解构对象属性别名</h5>
<pre><code class="language-js">const obj = { a: 0, b: 1, c: 2 };
const { a, b: d, c: e } = obj;
// a d e =&gt; 0 1 2
</code></pre>
<h5 id="解构对象属性默认值">解构对象属性默认值</h5>
<pre><code class="language-js">const obj = { a: 0, b: 1, c: 2 };
const { a, b = 2, d = 3 } = obj;
// a b d =&gt; 0 1 3
</code></pre>
<h3 id="function-skill">Function Skill</h3>
<h5 id="函数自执行">函数自执行</h5>
<pre><code class="language-js">const Func = function() {}(); // 常用

(function() {})(); // 常用
(function() {}()); // 常用
[function() {}()];

+ function() {}();
- function() {}();
~ function() {}();
! function() {}();

newfunction() {};
newfunction() {}();
voidfunction() {}();
typeoffunction() {}();
deletefunction() {}();

1, function() {}();
1 ^ function() {}();
1 &gt; function() {}();
</code></pre>
<h5 id="隐式返回值">隐式返回值</h5>
<blockquote>
<p>❝</p>
<p>只能用于<code>单语句返回值箭头函数</code>，如果返回值是对象必须使用<code>()</code>包住</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const Func = function(name) {
    return&quot;I Love &quot; + name;
};
// 换成
const Func = name =&gt;&quot;I Love &quot; + name;
</code></pre>
<h5 id="一次性函数">一次性函数</h5>
<blockquote>
<p>❝</p>
<p>适用于运行一些只需执行一次的初始化代码</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">function Func() {
    console.log(&quot;x&quot;);
    Func = function() {
        console.log(&quot;y&quot;);
    }
}
</code></pre>
<h5 id="惰性载入函数">惰性载入函数</h5>
<blockquote>
<p>❝</p>
<p>函数内判断分支较多较复杂时可大大节约资源开销</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">function Func() {
    if (a === b) {
        console.log(&quot;x&quot;);
    } else {
        console.log(&quot;y&quot;);
    }
}
// 换成
function Func() {
    if (a === b) {
        Func = function() {
            console.log(&quot;x&quot;);
        }
    } else {
        Func = function() {
            console.log(&quot;y&quot;);
        }
    }
    return Func();
}
</code></pre>
<h5 id="检测非空参数">检测非空参数</h5>
<pre><code class="language-js">function IsRequired() {
    thrownewError(&quot;param is required&quot;);
}
function Func(name = IsRequired()) {
    console.log(&quot;I Love &quot; + name);
}
Func(); // &quot;param is required&quot;
Func(&quot;You&quot;); // &quot;I Love You&quot;
</code></pre>
<h5 id="字符串创建函数">字符串创建函数</h5>
<pre><code class="language-js">const Func = newFunction(&quot;name&quot;, &quot;console.log(\&quot;I Love \&quot; + name)&quot;);
</code></pre>
<h5 id="优雅处理错误信息">优雅处理错误信息</h5>
<pre><code class="language-js">try {
    Func();
} catch (e) {
    location.href = &quot;https://stackoverflow.com/search?q=[js]+&quot; + e.message;
}
</code></pre>
<h5 id="优雅处理asyncawait参数">优雅处理Async/Await参数</h5>
<pre><code class="language-js">function AsyncTo(promise) {
    return promise.then(data =&gt; [null, data]).catch(err =&gt; [err]);
}
const [err, res] = await AsyncTo(Func());
</code></pre>
<h5 id="优雅处理多个函数返回值">优雅处理多个函数返回值</h5>
<pre><code class="language-js">function Func() {
    returnPromise.all([
        fetch(&quot;/user&quot;),
        fetch(&quot;/comment&quot;)
    ]);
}
const [user, comment] = await Func(); // 需在async包围下使用
</code></pre>
<h3 id="dom-skill">DOM Skill</h3>
<h5 id="显示全部dom边框">显示全部DOM边框</h5>
<blockquote>
<p>❝</p>
<p>调试页面元素边界时使用</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">[].forEach.call($$(&quot;*&quot;), dom =&gt; {
    dom.style.outline = &quot;1px solid #&quot; + (~~(Math.random() * (1 &lt;&lt; 24))).toString(16);
});
</code></pre>
<h5 id="自适应页面">自适应页面</h5>
<blockquote>
<p>❝</p>
<p>页面基于一张设计图但需做多款机型自适应，元素尺寸使用<code>rem</code>进行设置</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">function AutoResponse(width = 750) {
    const target = document.documentElement;
    target.clientWidth &gt;= 600
        ? (target.style.fontSize = &quot;80px&quot;)
        : (target.style.fontSize = target.clientWidth / width * 100 + &quot;px&quot;);
}
</code></pre>
<h5 id="过滤xss">过滤XSS</h5>
<pre><code class="language-js">function FilterXss(content) {
    let elem = document.createElement(&quot;div&quot;);
    elem.innerText = content;
    const result = elem.innerHTML;
    elem = null;
    return result;
}
</code></pre>
<h5 id="存取localstorage">存取LocalStorage</h5>
<blockquote>
<p>❝</p>
<p>反序列化取，序列化存</p>
<p>❞</p>
</blockquote>
<pre><code class="language-js">const love = JSON.parse(localStorage.getItem(&quot;love&quot;));
localStorage.setItem(&quot;love&quot;, JSON.stringify(&quot;I Love You&quot;));
</code></pre>
<h3 id=""></h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MongoDB设置权限]]></title>
        <id>https://herryle.github.io/101/</id>
        <link href="https://herryle.github.io/101/">
        </link>
        <updated>2019-02-27T01:33:08.000Z</updated>
        <content type="html"><![CDATA[<h1 id="mongodb设置权限">MongoDB设置权限</h1>
<ol>
<li>
<p>输入命令行mongo，进入mongodb环境</p>
<pre><code class="language-shellsh">mongo
</code></pre>
</li>
<li>
<p>切换到admin 数据库</p>
<pre><code>use admin
</code></pre>
</li>
<li>
<p>给admin设置用户密码</p>
<ul>
<li>user：用户名</li>
<li>pwd：密码</li>
<li>roles：</li>
</ul>
<pre><code class="language-shell">db.createUser({user: 'root', pwd: 'admin_mima', roles: ['root']})
</code></pre>
</li>
<li>
<p>验证是否成功，db.auth(用户名，密码)</p>
<pre><code>db.auth('root','admin_mima')
</code></pre>
<p>如果返回1标拾验证成功，如果是0 则表示验证失败</p>
</li>
<li>
<p>以上步骤是给root设置密码，如果要给特定的库设置权限，打比方test_demo库,切换到数据库test_demo</p>
<pre><code class="language-shell">use test_demo
</code></pre>
</li>
<li>
<p>为test_demo添加用户，并且赋予权限</p>
<pre><code class="language-shell">db.createUser({ user: 'herry', pwd: 'herry_mima', roles: [{ role: 'readWrite', db: 'test_demo' }] })
</code></pre>
<p>这行代码意思是 创建一个herryl用户 给予读写权限 db表示该用户操作的数据库名。</p>
<p>Read：允许用户读取指定数据库<br>
readWrite：允许用户读写指定数据库<br>
dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile<br>
userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户<br>
clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。<br>
readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限<br>
readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限<br>
userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限<br>
dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。<br>
root：只在admin数据库中可用。超级账号，超级权限</p>
</li>
<li>
<p>一切搞定，重新开机mongodb，通过增加 <code>--auth</code> 开启安全登录</p>
<pre><code class="language-shell">mongod --dbpath /www/server/mongodb/data --auth
</code></pre>
</li>
<li>
<p>给数据库添加用户访问权限或者修改密码</p>
<pre><code class="language-shell"> db.addUser('user','pwd')
 db.auth('user','pwd')
  //修改用户密码 一定要经过admin验证才可以执行
 db.changeUserPassword('user','pwd'); 
</code></pre>
</li>
<li>
<p>或者通过宝塔面板mongodb配置页面来修改。</p>
<ul>
<li>bindIp修改为 0.0.0.0 允许外网访问</li>
<li>authorization 修改为 enabled 开启认证<br>
重启一下mongodb</li>
</ul>
<p>重启mongdb可以用命令行(/etc/init.d/mongodb restart)</p>
<pre><code class="language-shell">/etc/init.d/mongodb restart
</code></pre>
</li>
<li>
<p>完成</p>
</li>
</ol>
]]></content>
    </entry>
</feed>